from fastapi import APIRouter, Depends, HTTPException, UploadFile, File, Form
from sqlalchemy.orm import Session
from typing import List
from ..database import get_db
from ..models import Employee, AttendanceLog, Camera
from ..services.face_service import face_service
from ..services.camera_service import camera_service
import cv2
import numpy as np
from fastapi.responses import StreamingResponse
import io
import threading
import time
import datetime

router = APIRouter()

# Global lock for attendance logging to prevent race conditions
attendance_lock = threading.Lock()
# Dictionary to store last processed time for each employee to prevent duplicate logs
last_processed = {}
    all_emps = db.query(Employee).all()
    face_service.load_embeddings(all_emps)
    
    return {"id": new_emp.id, "name": new_emp.name}

@router.put("/employees/{emp_id}")
async def update_employee(
    emp_id: int,
    name: str = Form(...),
    department: str = Form(None),
    pin: str = Form(None),
    file: UploadFile = File(None),
    db: Session = Depends(get_db)
):
    emp = db.query(Employee).filter(Employee.id == emp_id).first()
    if not emp:
        raise HTTPException(status_code=404, detail="Employee not found")
    
    emp.name = name
    emp.department = department
    emp.pin = pin
    
    if file:
        content = await file.read()
        is_good, msg = face_service.check_face_quality(content)
        if not is_good:
            raise HTTPException(status_code=400, detail=f"Image quality check failed: {msg}")
        
        embedding_pickle = face_service.register_face(content)
        if embedding_pickle is None:
            raise HTTPException(status_code=400, detail="No face detected in the image")
            
        # Process image
        processed_content = face_service.process_profile_image(content)
            
        emp.embedding = embedding_pickle
        emp.photo = processed_content
        
        # Reload embeddings
        all_emps = db.query(Employee).all()
        face_service.load_embeddings(all_emps)
    
    db.commit()
    return {"status": "updated"}

@router.get("/employees/{emp_id}/photo")
def get_employee_photo(emp_id: int, db: Session = Depends(get_db)):
    emp = db.query(Employee).filter(Employee.id == emp_id).first()
    if not emp or not emp.photo:
        raise HTTPException(status_code=404, detail="Photo not found")
    
    return StreamingResponse(io.BytesIO(emp.photo), media_type="image/jpeg")

@router.post("/verify-pin/")
def verify_pin(employee_id: int = Form(...), pin: str = Form(...), db: Session = Depends(get_db)):
    emp = db.query(Employee).filter(Employee.id == employee_id).first()
    if not emp:
        raise HTTPException(status_code=404, detail="Employee not found")
    
    if emp.pin and emp.pin == pin:
        # Log attendance with Entry/Exit logic
        log_type = check_attendance_status(emp.id, db)
        if not log_type:
            return {"status": "already_logged", "name": emp.name, "message": "Already logged Entry and Exit for today."}

        log = AttendanceLog(employee_id=emp.id, employee_name=emp.name, camera_id="PIN", confidence=1.0, type=log_type)
        db.add(log)
        db.commit()
        return {"status": "verified", "name": emp.name, "type": log_type}
    else:
        raise HTTPException(status_code=401, detail="Invalid PIN")

@router.get("/employees/")
def read_employees(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    employees = db.query(Employee).offset(skip).limit(limit).all()
    return [{"id": e.id, "name": e.name, "department": e.department} for e in employees]

@router.delete("/employees/{emp_id}")
def delete_employee(emp_id: int, db: Session = Depends(get_db)):
    emp = db.query(Employee).filter(Employee.id == emp_id).first()
    if not emp:
        raise HTTPException(status_code=404, detail="Employee not found")
    db.delete(emp)
    db.commit()
    
    # Reload embeddings
    all_emps = db.query(Employee).all()
    face_service.load_embeddings(all_emps)
    return {"status": "deleted"}

@router.post("/recognize/")
async def recognize_face(file: UploadFile = File(...)):
    """Recognize face from uploaded image"""
    try:
        contents = await file.read()
        nparr = np.frombuffer(contents, np.uint8)
        img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
        
        if img is None:
            raise HTTPException(status_code=400, detail="Invalid image")
        
        # Recognize faces
        results = face_service.recognize_faces(img)
        
        if not results:
            return {"name": "Unknown", "confidence": 0.0, "employee_id": None}
        
        # Get the first (best) result
        name, bbox, conf, emp_id, kps = results[0]
        
        # Get server timestamp
        server_time = datetime.datetime.now().strftime("%H:%M:%S")
        
        return {
            "name": name,
            "confidence": float(conf),
            "employee_id": emp_id,
            "timestamp": server_time
        }
    except Exception as e:
        print(f"Recognition error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# --- Cameras ---

@router.post("/cameras/")
def create_camera(name: str, source: str, db: Session = Depends(get_db)):
    new_cam = Camera(name=name, source=source)
    db.add(new_cam)
    db.commit()
    db.refresh(new_cam)
    
    # Start the camera
    camera_service.start_camera(new_cam.id, new_cam.source)
    
    return new_cam

@router.get("/cameras/")
def read_cameras(db: Session = Depends(get_db)):
    return db.query(Camera).all()

@router.delete("/cameras/{cam_id}")
def delete_camera(cam_id: int, db: Session = Depends(get_db)):
    cam = db.query(Camera).filter(Camera.id == cam_id).first()
    if not cam:
        raise HTTPException(status_code=404, detail="Camera not found")
    
    camera_service.stop_camera(cam.id)
    db.delete(cam)
    db.commit()
    return {"status": "deleted"}

@router.put("/cameras/{cam_id}/toggle")
def toggle_camera(cam_id: int, db: Session = Depends(get_db)):
    cam = db.query(Camera).filter(Camera.id == cam_id).first()
    if not cam:
        raise HTTPException(status_code=404, detail="Camera not found")
    
    cam.is_active = 1 if cam.is_active == 0 else 0
    db.commit()
    
    if cam.is_active:
        camera_service.start_camera(cam.id, cam.source)
    else:
        camera_service.stop_camera(cam.id)
        
    return {"status": "toggled", "is_active": cam.is_active}

@router.put("/cameras/{cam_id}/select")
def select_camera(cam_id: int, db: Session = Depends(get_db)):
    # Deselect all
    db.query(Camera).update({Camera.is_selected: 0})
    
    # Select target
    cam = db.query(Camera).filter(Camera.id == cam_id).first()
    if not cam:
        raise HTTPException(status_code=404, detail="Camera not found")
    
    cam.is_selected = 1
    db.commit()
    return {"status": "selected", "camera": cam.name}

# --- Streaming & Recognition ---

def generate_frames(camera_id: int, db_session_factory):
    frame_count = 0
    skip_frames = 2 # Process 1 out of 3 frames for detection
    last_results = []
    
    # Create a local session for logging
    db = db_session_factory()
    
    while True:
        frame = camera_service.get_frame(camera_id)
        if frame is None:
            time.sleep(0.01)
            continue

        frame_count += 1
        h, w = frame.shape[:2]
        
        # Draw Verification Zone (Static)
        # Matches logic in is_face_strictly_centered: x 30-70%, y 25-75%
        # Draw an ellipse or rounded rectangle
        zone_x1, zone_x2 = int(w * 0.30), int(w * 0.70)
        zone_y1, zone_y2 = int(h * 0.25), int(h * 0.75)
        
        # Draw semi-transparent overlay or just a thick line
        cv2.ellipse(frame, ((zone_x1+zone_x2)//2, (zone_y1+zone_y2)//2), 
                    ((zone_x2-zone_x1)//2, (zone_y2-zone_y1)//2), 
                    0, 0, 360, (255, 255, 255), 2)
        
        # Run detection/recognition
        if frame_count % (skip_frames + 1) == 0:
            last_results = face_service.recognize_faces(frame)
        
        # Draw results
        for name, bbox, conf, emp_id, kps in last_results:
            box = bbox.astype(int)
            
            # Draw Landmarks (5 points)
            if kps is not None:
                for kp in kps:
                    cv2.circle(frame, (int(kp[0]), int(kp[1])), 3, (0, 255, 255), -1)

            # Determine color and label based on confidence
            if name == "Positioning...":
                color = (0, 255, 255) # Yellow
                top_label = "Please Center Face"
                bottom_label = None
            elif name == "Unknown":
                # Check confidence levels for unknown/low confidence matches
                # Even if unknown, we might have a score (max_sim) but it was below threshold
                # But here 'conf' is passed. If it's "Unknown", conf might be the best match score below threshold.
                
                if conf < 0.90:
                    color = (0, 0, 255) # Red
                else:
                    color = (0, 255, 0) # Green
                
                top_label = f"Precision: {int(conf*100)}%"
                bottom_label = None
            else:
                # Known face (conf > 0.90)
                color = (0, 255, 0) # Green
                top_label = f"Precision: {int(conf*100)}%"
                bottom_label = "Verifie" # No accents in cv2.putText usually

                # Log attendance if known and high confidence (async to avoid blocking)
                if emp_id:
                    log_type = check_attendance_status(emp_id, db)
                    
                    if log_type:
                        # Log in background thread to avoid blocking video stream
                        def log_async():
                            db_async = SessionLocal()
                            try:
                                log = AttendanceLog(employee_id=emp_id, employee_name=name, camera_id=f"Cam {camera_id}", confidence=conf, type=log_type)
                                db_async.add(log)
                                db_async.commit()
                                print(f"Logged {log_type} for {name}")
                            except Exception as e:
                                print(f"Error logging attendance: {e}")
                            finally:
                                db_async.close()
                        
                        threading.Thread(target=log_async, daemon=True).start()
                        # Update label to show what was logged
                        bottom_label = f"Verifie - {log_type}"

            cv2.rectangle(frame, (box[0], box[1]), (box[2], box[3]), color, 2)
            
            if top_label:
                cv2.putText(frame, top_label, (box[0], box[1]-10), cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)
            
            if bottom_label:
                cv2.putText(frame, bottom_label, (box[0], box[3]+25), cv2.FONT_HERSHEY_SIMPLEX, 0.8, color, 2)

        ret, buffer = cv2.imencode('.jpg', frame)
        frame_bytes = buffer.tobytes()
        yield (b'--frame\r\n'
               b'Content-Type: image/jpeg\r\n\r\n' + frame_bytes + b'\r\n')
    
    db.close()

from ..database import get_db, SessionLocal

@router.get("/stream/{camera_id}")
def video_feed(camera_id: int):
    return StreamingResponse(generate_frames(camera_id, SessionLocal), media_type="multipart/x-mixed-replace; boundary=frame")

# --- Attendance ---

def check_attendance_status(employee_id: int, db: Session):
    """
    Determine if we should log ENTRY, EXIT, or nothing.
    Returns: 'ENTRY', 'EXIT', or None (if blocked)
    """
    # Get today's logs
    today_start = datetime.datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
    logs = db.query(AttendanceLog).filter(
        AttendanceLog.employee_id == employee_id,
        AttendanceLog.timestamp >= today_start
    ).order_by(AttendanceLog.timestamp.asc()).all()
    
    # Strict Logic: 1 Entry / 1 Exit per day
    has_entry = any(log.type == 'ENTRY' for log in logs)
    has_exit = any(log.type == 'EXIT' for log in logs)
    
    if has_exit:
        print(f"Blocked: Already has EXIT for today.")
        return None # Day complete
        
    if not has_entry:
        return 'ENTRY'
        
    # If has_entry and not has_exit:
    # Check cooldown (4 hours = 14400 seconds)
    last_log = logs[-1]
    time_diff = (datetime.datetime.now() - last_log.timestamp.replace(tzinfo=None)).total_seconds()
    if time_diff < 14400: # 4 hours
        print(f"Blocked: Cooldown active. {14400 - time_diff}s remaining.")
        return None

    return 'EXIT'

@router.post("/log_attendance/")
def log_attendance(employee_id: int, camera_id: str, confidence: float, db: Session = Depends(get_db)):
    with attendance_lock:
        # Backend Debounce: Check if we processed this employee recently (last 5 seconds)
        now = time.time()
        if employee_id in last_processed:
            if now - last_processed[employee_id] < 5:
                print(f"Blocked: Debounce active for Emp {employee_id}")
                return {"status": "debounced"}
        
        last_processed[employee_id] = now

        log_type = check_attendance_status(employee_id, db)
        print(f"Log Request: Emp {employee_id}, Conf {confidence}. Status: {log_type}")
        if not log_type:
            return {"status": "already_logged_or_blocked"}

    emp = db.query(Employee).filter(Employee.id == employee_id).first()
    if not emp:
        raise HTTPException(status_code=404, detail="Employee not found")

    # Calculate worked hours if EXIT
    worked_minutes = None
    if log_type == 'EXIT':
        today_start = datetime.datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        entry_log = db.query(AttendanceLog).filter(
            AttendanceLog.employee_id == employee_id,
            AttendanceLog.type == 'ENTRY',
            AttendanceLog.timestamp >= today_start
        ).order_by(AttendanceLog.timestamp.desc()).first()
        
        if entry_log:
            # Calculate minutes
            diff = datetime.datetime.now() - entry_log.timestamp
            worked_minutes = int(diff.total_seconds() / 60)

    log = AttendanceLog(employee_id=employee_id, employee_name=emp.name, camera_id=camera_id, confidence=confidence, type=log_type, worked_minutes=worked_minutes)
    db.add(log)
    db.commit()
    return {"status": "logged", "type": log_type, "worked_minutes": worked_minutes}

@router.get("/attendance/")
def read_attendance(
    skip: int = 0, 
    limit: int = 100, 
    start_date: str = None,
    end_date: str = None,
    employee_id: int = None,
    camera_id: str = None,
    db: Session = Depends(get_db)
):
    query = db.query(AttendanceLog)

    if start_date:
        try:
            s_date = datetime.datetime.fromisoformat(start_date)
            query = query.filter(AttendanceLog.timestamp >= s_date)
        except ValueError:
            pass # Ignore invalid date format
            
    if end_date:
        try:
            e_date = datetime.datetime.fromisoformat(end_date)
            # Set to end of day if only date provided, or trust isoformat
            if len(end_date) <= 10: # YYYY-MM-DD
                e_date = e_date.replace(hour=23, minute=59, second=59)
            query = query.filter(AttendanceLog.timestamp <= e_date)
        except ValueError:
            pass

    if employee_id:
        query = query.filter(AttendanceLog.employee_id == employee_id)
        
    if camera_id:
        query = query.filter(AttendanceLog.camera_id.contains(camera_id))

    return query.order_by(AttendanceLog.timestamp.desc()).offset(skip).limit(limit).all()

@router.delete("/attendance/{log_id}")
def delete_attendance_log(log_id: int, db: Session = Depends(get_db)):
    log = db.query(AttendanceLog).filter(AttendanceLog.id == log_id).first()
    if not log:
        raise HTTPException(status_code=404, detail="Log not found")
    db.delete(log)
    db.commit()
    return {"status": "deleted"}

@router.delete("/attendance/")
def delete_all_attendance_logs(db: Session = Depends(get_db)):
    db.query(AttendanceLog).delete()
    db.commit()
    return {"status": "all_deleted"}

@router.get("/work_time/{employee_id}")
def get_work_time(employee_id: int, db: Session = Depends(get_db)):
    """Calculate work time for an employee today"""
    today_start = datetime.datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
    logs = db.query(AttendanceLog).filter(
        AttendanceLog.employee_id == employee_id,
        AttendanceLog.timestamp >= today_start
    ).order_by(AttendanceLog.timestamp.asc()).all()
    
    if len(logs) < 2:
        return {"work_hours": 0, "status": "incomplete"}
    
    entry_log = next((log for log in logs if log.type == 'ENTRY'), None)
    exit_log = next((log for log in logs if log.type == 'EXIT'), None)
    
    if not entry_log or not exit_log:
        return {"work_minutes": 0, "status": "incomplete"}
    
    time_diff = (exit_log.timestamp.replace(tzinfo=None) - entry_log.timestamp.replace(tzinfo=None)).total_seconds()
    work_minutes = int(time_diff / 60)
    
    return {
        "work_minutes": work_minutes,
        "status": "complete" if work_minutes >= 300 else "insufficient", # 5 hours = 300 minutes
        "minimum_required": 300,
        "entry_time": entry_log.timestamp.isoformat(),
        "exit_time": exit_log.timestamp.isoformat()
    }
